{"/home/travis/build/npmtest/node-npmtest-nodejs-websocket/test.js":"/* istanbul instrument in package npmtest_nodejs_websocket */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nodejs-websocket/lib.npmtest_nodejs_websocket.js":"/* istanbul instrument in package npmtest_nodejs_websocket */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nodejs_websocket = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nodejs_websocket = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nodejs-websocket/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nodejs-websocket && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nodejs_websocket */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nodejs_websocket\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nodejs_websocket.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_nodejs_websocket.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nodejs_websocket.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_nodejs_websocket.__dirname + '/lib.npmtest_nodejs_websocket.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nodejs-websocket/node_modules/nodejs-websocket/index.js":"'use strict'\r\n\r\nvar Server = require('./Server'),\r\n\tConnection = require('./Connection'),\r\n\tnet = require('net'),\r\n\ttls = require('tls'),\r\n\turl = require('url')\r\n\r\n/**\r\n * Create a WebSocket server\r\n * @param {Object} [options] will be passed to net.createServer() or tls.createServer(), with the additional property 'secure' (a boolean)\r\n * @param {Function} callback will be added as 'connection' listener\r\n * @returns {Server}\r\n */\r\nexports.createServer = function (options, callback) {\r\n\tif (typeof options === 'function' || !arguments.length) {\r\n\t\treturn new Server(false, options)\r\n\t}\r\n\treturn new Server(Boolean(options.secure), options, callback)\r\n}\r\n\r\n/**\r\n * Create a WebSocket client\r\n * @param {string} URL with the format 'ws://localhost:8000/chat' (the port can be ommited)\r\n * @param {Object} [options] will be passed to net.connect() or tls.connect()\r\n * @param {Function} callback will be added as 'connect' listener\r\n * @returns {Connection}\r\n */\r\nexports.connect = function (URL, options, callback) {\r\n\tvar socket\r\n\r\n\tif (typeof options === 'function') {\r\n\t\tcallback = options\r\n\t\toptions = undefined\r\n\t}\r\n\toptions = options || {}\r\n\r\n\tvar connectionOptions = parseWSURL(URL)\r\n\toptions.port = connectionOptions.port\r\n\toptions.host = connectionOptions.host\r\n\r\n\tconnectionOptions.extraHeaders = options.extraHeaders\r\n\tconnectionOptions.protocols = options.protocols\r\n\r\n\tif (connectionOptions.secure) {\r\n\t\tsocket = tls.connect(options)\r\n\t} else {\r\n\t\tsocket = net.connect(options)\r\n\t}\r\n\r\n\treturn new Connection(socket, connectionOptions, callback)\r\n}\r\n\r\n/**\r\n * Set the minimum size of a pack of binary data to send in a single frame\r\n * @param {number} bytes\r\n */\r\nexports.setBinaryFragmentation = function (bytes) {\r\n\tConnection.binaryFragmentation = bytes\r\n}\r\n\r\n/**\r\n * Set the maximum size the internal Buffer can grow, to avoid memory attacks\r\n * @param {number} bytes\r\n */\r\nexports.setMaxBufferLength = function (bytes) {\r\n\tConnection.maxBufferLength = bytes\r\n}\r\n\r\n/**\r\n * Parse the WebSocket URL\r\n * @param {string} URL\r\n * @returns {Object}\r\n * @private\r\n */\r\nfunction parseWSURL(URL) {\r\n\tvar parts, secure\r\n\r\n\tparts = url.parse(URL)\r\n\r\n\tparts.protocol = parts.protocol || 'ws:'\r\n\tif (parts.protocol === 'ws:') {\r\n\t\tsecure = false\r\n\t} else if (parts.protocol === 'wss:') {\r\n\t\tsecure = true\r\n\t} else {\r\n\t\tthrow new Error('Invalid protocol ' + parts.protocol + '. It must be ws or wss')\r\n\t}\r\n\r\n\tparts.port = parts.port || (secure ? 443 : 80)\r\n\tparts.path = parts.path || '/'\r\n\r\n\treturn {\r\n\t\tpath: parts.path,\r\n\t\tport: parts.port,\r\n\t\tsecure: secure,\r\n\t\thost: parts.hostname\r\n\t}\r\n}","/home/travis/build/npmtest/node-npmtest-nodejs-websocket/node_modules/nodejs-websocket/Server.js":"/**\r\n * @file Represents a websocket server\r\n */\r\n'use strict'\r\n\r\nfunction nop() {}\r\n\r\nvar util = require('util'),\r\n\tnet = require('net'),\r\n\ttls = require('tls'),\r\n\tevents = require('events'),\r\n\tConnection\r\n\r\n/**\r\n * @callback SelectProtocolCallback\r\n * @param {Connection} connection\r\n * @param {Array<string>} protocols\r\n * @returns {?string}\r\n */\r\n\r\n/**\r\n * Creates a new ws server and starts listening for new connections\r\n * @class\r\n * @param {boolean} secure indicates if it should use tls\r\n * @param {Object} [options] will be passed to net.createServer() or tls.createServer()\r\n * @param {Array<string>} [options.validProtocols]\r\n * @param {SelectProtocolCallback} [options.selectProtocol]\r\n * @param {Function} [callback] will be added as \"connection\" listener\r\n * @inherits EventEmitter\r\n * @event listening\r\n * @event close\r\n * @event error an error object is passed\r\n * @event connection a Connection object is passed\r\n */\r\nfunction Server(secure, options, callback) {\r\n\tvar that = this\r\n\r\n\tif (typeof options === 'function') {\r\n\t\tcallback = options\r\n\t\toptions = undefined\r\n\t}\r\n\r\n\tvar onConnection = function (socket) {\r\n\t\tvar conn = new Connection(socket, that, function () {\r\n\t\t\tthat.connections.push(conn)\r\n\t\t\tconn.removeListener('error', nop)\r\n\t\t\tthat.emit('connection', conn)\r\n\t\t})\r\n\t\tconn.on('close', function () {\r\n\t\t\tvar pos = that.connections.indexOf(conn)\r\n\t\t\tif (pos !== -1) {\r\n\t\t\t\tthat.connections.splice(pos, 1)\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\t// Ignore errors before the connection is established\r\n\t\tconn.on('error', nop)\r\n\t}\r\n\r\n\tif (secure) {\r\n\t\tthis.socket = tls.createServer(options, onConnection)\r\n\t} else {\r\n\t\tthis.socket = net.createServer(options, onConnection)\r\n\t}\r\n\r\n\tthis.socket.on('close', function () {\r\n\t\tthat.emit('close')\r\n\t})\r\n\tthis.socket.on('error', function (err) {\r\n\t\tthat.emit('error', err)\r\n\t})\r\n\tthis.connections = []\r\n\r\n\t// super constructor\r\n\tevents.EventEmitter.call(this)\r\n\tif (callback) {\r\n\t\tthis.on('connection', callback)\r\n\t}\r\n\r\n\t// Add protocol agreement handling\r\n\t/**\r\n\t * @member {?SelectProtocolCallback}\r\n\t * @private\r\n\t */\r\n\tthis._selectProtocol = null\r\n\r\n\tif (options && options.selectProtocol) {\r\n\t\t// User-provided logic\r\n\t\tthis._selectProtocol = options.selectProtocol\r\n\t} else if (options && options.validProtocols) {\r\n\t\t// Default logic\r\n\t\tthis._selectProtocol = this._buildSelectProtocol(options.validProtocols)\r\n\t}\r\n}\r\n\r\nutil.inherits(Server, events.EventEmitter)\r\nmodule.exports = Server\r\n\r\nConnection = require('./Connection')\r\n\r\n/**\r\n * Start listening for connections\r\n * @param {number} port\r\n * @param {string} [host]\r\n * @param {Function} [callback] will be added as \"connection\" listener\r\n */\r\nServer.prototype.listen = function (port, host, callback) {\r\n\tvar that = this\r\n\r\n\tif (typeof host === 'function') {\r\n\t\tcallback = host\r\n\t\thost = undefined\r\n\t}\r\n\r\n\tif (callback) {\r\n\t\tthis.on('listening', callback)\r\n\t}\r\n\r\n\tthis.socket.listen(port, host, function () {\r\n\t\tthat.emit('listening')\r\n\t})\r\n\r\n\treturn this\r\n}\r\n\r\n/**\r\n * Stops the server from accepting new connections and keeps existing connections.\r\n * This function is asynchronous, the server is finally closed when all connections are ended and the server emits a 'close' event.\r\n * The optional callback will be called once the 'close' event occurs.\r\n * @param {function()} [callback]\r\n */\r\nServer.prototype.close = function (callback) {\r\n\tif (callback) {\r\n\t\tthis.once('close', callback)\r\n\t}\r\n\tthis.socket.close()\r\n}\r\n\r\n/**\r\n * Create a resolver to pick the client's most preferred protocol the server recognises\r\n * @param {Array<string>} validProtocols\r\n * @returns {SelectProtocolCallback}\r\n * @private\r\n */\r\nServer.prototype._buildSelectProtocol = function (validProtocols) {\r\n\treturn function (conn, protocols) {\r\n\t\tvar i\r\n\r\n\t\tfor (i = 0; i < protocols.length; i++) {\r\n\t\t\tif (validProtocols.indexOf(protocols[i]) !== -1) {\r\n\t\t\t\t// A valid protocol was found\r\n\t\t\t\treturn protocols[i]\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// No agreement\r\n\t}\r\n}","/home/travis/build/npmtest/node-npmtest-nodejs-websocket/node_modules/nodejs-websocket/Connection.js":"/**\r\n * @file Represents a connection (both client and server sides)\r\n */\r\n'use strict'\r\n\r\nvar util = require('util'),\r\n\tevents = require('events'),\r\n\tcrypto = require('crypto'),\r\n\tInStream = require('./InStream'),\r\n\tOutStream = require('./OutStream'),\r\n\tframe = require('./frame'),\r\n\tServer = require('./Server')\r\n\r\n/**\r\n * @typedef {Object} Connection~Options\r\n * @param {string} path\r\n * @param {string} host\r\n * @param {?Object<string>} extraHeaders\r\n * @param {?Array<string>} protocols\r\n */\r\n\r\n/**\r\n * @class\r\n * @param {(net.Socket|tls.CleartextStream)} socket a net or tls socket\r\n * @param {(Server|Connection~Options)} parentOrOptions parent in case of server-side connection,  object in case of client-side\r\n * @param {Function} [callback] will be added as a listener to 'connect'\r\n * @inherits EventEmitter\r\n * @event close the numeric code and string reason will be passed\r\n * @event error an error object is passed\r\n * @event text a string is passed\r\n * @event binary a inStream object is passed\r\n * @event pong a string is passed\r\n * @event connect\r\n */\r\nfunction Connection(socket, parentOrOptions, callback) {\r\n\tvar that = this,\r\n\t\tconnectEvent\r\n\r\n\tif (parentOrOptions instanceof Server) {\r\n\t\t// Server-side connection\r\n\t\tthis.server = parentOrOptions\r\n\t\tthis.path = null\r\n\t\tthis.host = null\r\n\t\tthis.extraHeaders = null\r\n\t\tthis.protocols = []\r\n\t} else {\r\n\t\t// Client-side\r\n\t\tthis.server = null\r\n\t\tthis.path = parentOrOptions.path\r\n\t\tthis.host = parentOrOptions.host\r\n\t\tthis.extraHeaders = parentOrOptions.extraHeaders\r\n\t\tthis.protocols = parentOrOptions.protocols || []\r\n\t}\r\n\r\n\tthis.protocol = undefined\r\n\tthis.socket = socket\r\n\tthis.readyState = this.CONNECTING\r\n\tthis.buffer = new Buffer(0)\r\n\tthis.frameBuffer = null // string for text frames and InStream for binary frames\r\n\tthis.outStream = null // current allocated OutStream object for sending binary frames\r\n\tthis.key = null // the Sec-WebSocket-Key header\r\n\tthis.headers = {} // read only map of header names and values. Header names are lower-cased\r\n\r\n\t// Set listeners\r\n\tsocket.on('readable', function () {\r\n\t\tthat.doRead()\r\n\t})\r\n\r\n\tsocket.on('error', function (err) {\r\n\t\tthat.emit('error', err)\r\n\t})\r\n\r\n\tif (!this.server) {\r\n\t\tconnectEvent = socket.constructor.name === 'CleartextStream' ? 'secureConnect' : 'connect'\r\n\t\tsocket.on(connectEvent, function () {\r\n\t\t\tthat.startHandshake()\r\n\t\t})\r\n\t}\r\n\r\n\t// Close listeners\r\n\tvar onclose = function () {\r\n\t\tif (that.readyState === that.CONNECTING || that.readyState === that.OPEN) {\r\n\t\t\tthat.emit('close', 1006, '')\r\n\t\t}\r\n\t\tthat.readyState = this.CLOSED\r\n\t\tif (that.frameBuffer instanceof InStream) {\r\n\t\t\tthat.frameBuffer.end()\r\n\t\t\tthat.frameBuffer = null\r\n\t\t}\r\n\t\tif (that.outStream instanceof OutStream) {\r\n\t\t\tthat.outStream.end()\r\n\t\t\tthat.outStream = null\r\n\t\t}\r\n\t}\r\n\tsocket.once('close', onclose)\r\n\tsocket.once('finish', onclose)\r\n\r\n\t// super constructor\r\n\tevents.EventEmitter.call(this)\r\n\tif (callback) {\r\n\t\tthis.once('connect', callback)\r\n\t}\r\n}\r\n\r\nutil.inherits(Connection, events.EventEmitter)\r\nmodule.exports = Connection\r\n\r\n/**\r\n * Minimum size of a pack of binary data to send in a single frame\r\n * @property {number} binaryFragmentation\r\n */\r\nConnection.binaryFragmentation = 512 * 1024 // .5 MiB\r\n\r\n/**\r\n * The maximum size the internal Buffer can grow\r\n * If at any time it stays bigger than this, the connection will be closed with code 1009\r\n * This is a security measure, to avoid memory attacks\r\n * @property {number} maxBufferLength\r\n */\r\nConnection.maxBufferLength = 2 * 1024 * 1024 // 2 MiB\r\n\r\n/**\r\n * Possible ready states for the connection\r\n * @constant {number} CONNECTING\r\n * @constant {number} OPEN\r\n * @constant {number} CLOSING\r\n * @constant {number} CLOSED\r\n */\r\nConnection.prototype.CONNECTING = 0\r\nConnection.prototype.OPEN = 1\r\nConnection.prototype.CLOSING = 2\r\nConnection.prototype.CLOSED = 3\r\n\r\n/**\r\n * Send a given string to the other side\r\n * @param {string} str\r\n * @param {Function} [callback] will be executed when the data is finally written out\r\n */\r\nConnection.prototype.sendText = function (str, callback) {\r\n\tif (this.readyState === this.OPEN) {\r\n\t\tif (!this.outStream) {\r\n\t\t\treturn this.socket.write(frame.createTextFrame(str, !this.server), callback)\r\n\t\t}\r\n\t\tthis.emit('error', new Error('You can\\'t send a text frame until you finish sending binary frames'))\r\n\t} else {\r\n\t\tthis.emit('error', new Error('You can\\'t write to a non-open connection'))\r\n\t}\r\n}\r\n\r\n/**\r\n * Request for a OutStream to send binary data\r\n * @returns {OutStream}\r\n */\r\nConnection.prototype.beginBinary = function () {\r\n\tif (this.readyState === this.OPEN) {\r\n\t\tif (!this.outStream) {\r\n\t\t\treturn (this.outStream = new OutStream(this, Connection.binaryFragmentation))\r\n\t\t}\r\n\t\tthis.emit('error', new Error('You can\\'t send more binary frames until you finish sending the previous binary frames'))\r\n\t} else {\r\n\t\tthis.emit('error', new Error('You can\\'t write to a non-open connection'))\r\n\t}\r\n}\r\n\r\n/**\r\n * Sends a binary buffer at once\r\n * @param {Buffer} data\r\n * @param {Function} [callback] will be executed when the data is finally written out\r\n */\r\nConnection.prototype.sendBinary = function (data, callback) {\r\n\tif (this.readyState === this.OPEN) {\r\n\t\tif (!this.outStream) {\r\n\t\t\treturn this.socket.write(frame.createBinaryFrame(data, !this.server, true, true), callback)\r\n\t\t}\r\n\t\tthis.emit('error', new Error('You can\\'t send more binary frames until you finish sending the previous binary frames'))\r\n\t} else {\r\n\t\tthis.emit('error', new Error('You can\\'t write to a non-open connection'))\r\n\t}\r\n}\r\n\r\n/**\r\n * Sends a text or binary frame\r\n * @param {string|Buffer} data\r\n * @param {Function} [callback] will be executed when the data is finally written out\r\n */\r\nConnection.prototype.send = function (data, callback) {\r\n\tif (typeof data === 'string') {\r\n\t\tthis.sendText(data, callback)\r\n\t} else if (Buffer.isBuffer(data)) {\r\n\t\tthis.sendBinary(data, callback)\r\n\t} else {\r\n\t\tthrow new TypeError('data should be either a string or a Buffer instance')\r\n\t}\r\n}\r\n\r\n/**\r\n * Sends a ping to the remote\r\n * @param {string} [data=''] - optional ping data\r\n * @fires pong when pong reply is received\r\n */\r\nConnection.prototype.sendPing = function (data) {\r\n\tif (this.readyState === this.OPEN) {\r\n\t\tthis.socket.write(frame.createPingFrame(data || '', !this.server))\r\n\t} else {\r\n\t\tthis.emit('error', new Error('You can\\'t write to a non-open connection'))\r\n\t}\r\n}\r\n\r\n/**\r\n * Close the connection, sending a close frame and waiting for response\r\n * If the connection isn't OPEN, closes it without sending a close frame\r\n * @param {number} [code]\r\n * @param {string} [reason]\r\n * @fires close\r\n */\r\nConnection.prototype.close = function (code, reason) {\r\n\tif (this.readyState === this.OPEN) {\r\n\t\tthis.socket.write(frame.createCloseFrame(code, reason, !this.server))\r\n\t\tthis.readyState = this.CLOSING\r\n\t} else if (this.readyState !== this.CLOSED) {\r\n\t\tthis.socket.end()\r\n\t\tthis.readyState = this.CLOSED\r\n\t}\r\n\tthis.emit('close', code, reason)\r\n}\r\n\r\n/**\r\n * Reads contents from the socket and process it\r\n * @fires connect\r\n * @private\r\n */\r\nConnection.prototype.doRead = function () {\r\n\tvar buffer, temp\r\n\r\n\t// Fetches the data\r\n\tbuffer = this.socket.read()\r\n\tif (!buffer) {\r\n\t\t// Waits for more data\r\n\t\treturn\r\n\t}\r\n\r\n\t// Save to the internal buffer\r\n\tthis.buffer = Buffer.concat([this.buffer, buffer], this.buffer.length + buffer.length)\r\n\r\n\tif (this.readyState === this.CONNECTING) {\r\n\t\tif (!this.readHandshake()) {\r\n\t\t\t// May have failed or we're waiting for more data\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\r\n\tif (this.readyState !== this.CLOSED) {\r\n\t\t// Try to read as many frames as possible\r\n\t\twhile ((temp = this.extractFrame()) === true) {}\r\n\t\tif (temp === false) {\r\n\t\t\t// Protocol error\r\n\t\t\tthis.close(1002)\r\n\t\t} else if (this.buffer.length > Connection.maxBufferLength) {\r\n\t\t\t// Frame too big\r\n\t\t\tthis.close(1009)\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Create and send a handshake as a client\r\n * @private\r\n */\r\nConnection.prototype.startHandshake = function () {\r\n\tvar str, i, key, headers, header\r\n\tkey = new Buffer(16)\r\n\tfor (i = 0; i < 16; i++) {\r\n\t\tkey[i] = Math.floor(Math.random() * 256)\r\n\t}\r\n\tthis.key = key.toString('base64')\r\n\theaders = {\r\n\t\tHost: this.host,\r\n\t\tUpgrade: 'websocket',\r\n\t\tConnection: 'Upgrade',\r\n\t\t'Sec-WebSocket-Key': this.key,\r\n\t\t'Sec-WebSocket-Version': '13'\r\n\t}\r\n\r\n\tif (this.protocols && this.protocols.length) {\r\n\t\theaders['Sec-WebSocket-Protocol'] = this.protocols.join(', ')\r\n\t}\r\n\r\n\tfor (header in this.extraHeaders) {\r\n\t\theaders[header] = this.extraHeaders[header]\r\n\t}\r\n\r\n\tstr = this.buildRequest('GET ' + this.path + ' HTTP/1.1', headers)\r\n\tthis.socket.write(str)\r\n}\r\n\r\n/**\r\n * Try to read the handshake from the internal buffer\r\n * If it succeeds, the handshake data is consumed from the internal buffer\r\n * @returns {boolean} - whether the handshake was done\r\n * @private\r\n */\r\nConnection.prototype.readHandshake = function () {\r\n\tvar found = false,\r\n\t\ti, data\r\n\r\n\t// Do the handshake and try to connect\r\n\tif (this.buffer.length > Connection.maxBufferLength) {\r\n\t\t// Too big for a handshake\r\n\t\tif (this.server) {\r\n\t\t\tthis.socket.end('HTTP/1.1 400 Bad Request\\r\\n\\r\\n')\r\n\t\t} else {\r\n\t\t\tthis.socket.end()\r\n\t\t\tthis.emit('error', new Error('Handshake is too big'))\r\n\t\t}\r\n\t\treturn false\r\n\t}\r\n\r\n\t// Search for '\\r\\n\\r\\n'\r\n\tfor (i = 0; i < this.buffer.length - 3; i++) {\r\n\t\tif (this.buffer[i] === 13 && this.buffer[i + 2] === 13 &&\r\n\t\t\tthis.buffer[i + 1] === 10 && this.buffer[i + 3] === 10) {\r\n\t\t\tfound = true\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\tif (!found) {\r\n\t\t// Wait for more data\r\n\t\treturn false\r\n\t}\r\n\tdata = this.buffer.slice(0, i + 4).toString().split('\\r\\n')\r\n\tif (this.server ? this.answerHandshake(data) : this.checkHandshake(data)) {\r\n\t\tthis.buffer = this.buffer.slice(i + 4)\r\n\t\tthis.readyState = this.OPEN\r\n\t\tthis.emit('connect')\r\n\t\treturn true\r\n\t} else {\r\n\t\tthis.socket.end(this.server ? 'HTTP/1.1 400 Bad Request\\r\\n\\r\\n' : undefined)\r\n\t\treturn false\r\n\t}\r\n}\r\n\r\n/**\r\n * Read headers from HTTP protocol\r\n * Update the Connection#headers property\r\n * @param {string[]} lines one for each '\\r\\n'-separated HTTP request line\r\n * @private\r\n */\r\nConnection.prototype.readHeaders = function (lines) {\r\n\tvar i, match\r\n\r\n\t// Extract all headers\r\n\t// Ignore bad-formed lines and ignore the first line (HTTP header)\r\n\tfor (i = 1; i < lines.length; i++) {\r\n\t\tif ((match = lines[i].match(/^([a-z-]+): (.+)$/i))) {\r\n\t\t\tthis.headers[match[1].toLowerCase()] = match[2]\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Process and check a handshake answered by a server\r\n * @param {string[]} lines one for each '\\r\\n'-separated HTTP request line\r\n * @returns {boolean} if the handshake was sucessful. If not, the connection must be closed\r\n * @private\r\n */\r\nConnection.prototype.checkHandshake = function (lines) {\r\n\tvar key, sha1, protocol\r\n\r\n\t// First line\r\n\tif (lines.length < 4) {\r\n\t\tthis.emit('error', new Error('Invalid handshake: too short'))\r\n\t\treturn false\r\n\t}\r\n\tif (!lines[0].match(/^HTTP\\/\\d\\.\\d 101( .*)?$/i)) {\r\n\t\tthis.emit('error', new Error('Invalid handshake: invalid first line format'))\r\n\t\treturn false\r\n\t}\r\n\r\n\t// Extract all headers\r\n\tthis.readHeaders(lines)\r\n\r\n\t// Validate necessary headers\r\n\tif (!('upgrade' in this.headers) ||\r\n\t\t!('sec-websocket-accept' in this.headers) ||\r\n\t\t!('connection' in this.headers)) {\r\n\t\tthis.emit('error', new Error('Invalid handshake: missing required headers'))\r\n\t\treturn false\r\n\t}\r\n\tif (this.headers.upgrade.toLowerCase() !== 'websocket' ||\r\n\t\tthis.headers.connection.toLowerCase().split(', ').indexOf('upgrade') === -1) {\r\n\t\tthis.emit('error', new Error('Invalid handshake: invalid Upgrade or Connection header'))\r\n\t\treturn false\r\n\t}\r\n\tkey = this.headers['sec-websocket-accept']\r\n\r\n\t// Check protocol negotiation\r\n\tprotocol = this.headers['sec-websocket-protocol']\r\n\tif (this.protocols && this.protocols.length) {\r\n\t\t// The server must choose one from our list\r\n\t\tif (!protocol || this.protocols.indexOf(protocol) === -1) {\r\n\t\t\tthis.emit('error', new Error('Invalid handshake: no protocol was negotiated'))\r\n\t\t\treturn false\r\n\t\t}\r\n\t} else {\r\n\t\t// The server must not choose a protocol\r\n\t\tif (protocol) {\r\n\t\t\tthis.emit('error', new Error('Invalid handshake: no protocol negotiation was expected'))\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\tthis.protocol = protocol\r\n\r\n\t// Check the key\r\n\tsha1 = crypto.createHash('sha1')\r\n\tsha1.end(this.key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11')\r\n\tif (key !== sha1.read().toString('base64')) {\r\n\t\tthis.emit('error', new Error('Invalid handshake: hash mismatch'))\r\n\t\treturn false\r\n\t}\r\n\treturn true\r\n}\r\n\r\n/**\r\n * Process and answer a handshake started by a client\r\n * @param {string[]} lines one for each '\\r\\n'-separated HTTP request line\r\n * @returns {boolean} if the handshake was sucessful. If not, the connection must be closed with error 400-Bad Request\r\n * @private\r\n */\r\nConnection.prototype.answerHandshake = function (lines) {\r\n\tvar path, key, sha1, headers\r\n\r\n\t// First line\r\n\tif (lines.length < 6) {\r\n\t\treturn false\r\n\t}\r\n\tpath = lines[0].match(/^GET (.+) HTTP\\/\\d\\.\\d$/i)\r\n\tif (!path) {\r\n\t\treturn false\r\n\t}\r\n\tthis.path = path[1]\r\n\r\n\t// Extract all headers\r\n\tthis.readHeaders(lines)\r\n\r\n\t// Validate necessary headers\r\n\tif (!('host' in this.headers) ||\r\n\t\t!('sec-websocket-key' in this.headers) ||\r\n\t\t!('upgrade' in this.headers) ||\r\n\t\t!('connection' in this.headers)) {\r\n\t\treturn false\r\n\t}\r\n\tif (this.headers.upgrade.toLowerCase() !== 'websocket' ||\r\n\t\tthis.headers.connection.toLowerCase().split(', ').indexOf('upgrade') === -1) {\r\n\t\treturn false\r\n\t}\r\n\tif (this.headers['sec-websocket-version'] !== '13') {\r\n\t\treturn false\r\n\t}\r\n\r\n\tthis.key = this.headers['sec-websocket-key']\r\n\r\n\t// Agree on a protocol\r\n\tif ('sec-websocket-protocol' in this.headers) {\r\n\t\t// Parse\r\n\t\tthis.protocols = this.headers['sec-websocket-protocol'].split(',').map(function (each) {\r\n\t\t\treturn each.trim()\r\n\t\t})\r\n\r\n\t\t// Select protocol\r\n\t\tif (this.server._selectProtocol) {\r\n\t\t\tthis.protocol = this.server._selectProtocol(this, this.protocols)\r\n\t\t}\r\n\t}\r\n\r\n\t// Build and send the response\r\n\tsha1 = crypto.createHash('sha1')\r\n\tsha1.end(this.key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11')\r\n\tkey = sha1.read().toString('base64')\r\n\theaders = {\r\n\t\tUpgrade: 'websocket',\r\n\t\tConnection: 'Upgrade',\r\n\t\t'Sec-WebSocket-Accept': key\r\n\t}\r\n\tif (this.protocol) {\r\n\t\theaders['Sec-WebSocket-Protocol'] = this.protocol\r\n\t}\r\n\tthis.socket.write(this.buildRequest('HTTP/1.1 101 Switching Protocols', headers))\r\n\treturn true\r\n}\r\n\r\n/**\r\n * Try to extract frame contents from the buffer (and execute it)\r\n * @returns {(boolean|undefined)} false=something went wrong (the connection must be closed); undefined=there isn't enough data to catch a frame; true=the frame was successfully fetched and executed\r\n * @private\r\n */\r\nConnection.prototype.extractFrame = function () {\r\n\tvar fin, opcode, B, HB, mask, len, payload, start, i, hasMask\r\n\r\n\tif (this.buffer.length < 2) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// Is this the last frame in a sequence?\r\n\tB = this.buffer[0]\r\n\tHB = B >> 4\r\n\tif (HB % 8) {\r\n\t\t// RSV1, RSV2 and RSV3 must be clear\r\n\t\treturn false\r\n\t}\r\n\tfin = HB === 8\r\n\topcode = B % 16\r\n\r\n\tif (opcode !== 0 && opcode !== 1 && opcode !== 2 &&\r\n\t\topcode !== 8 && opcode !== 9 && opcode !== 10) {\r\n\t\t// Invalid opcode\r\n\t\treturn false\r\n\t}\r\n\tif (opcode >= 8 && !fin) {\r\n\t\t// Control frames must not be fragmented\r\n\t\treturn false\r\n\t}\r\n\r\n\tB = this.buffer[1]\r\n\thasMask = B >> 7\r\n\tif ((this.server && !hasMask) || (!this.server && hasMask)) {\r\n\t\t// Frames sent by clients must be masked\r\n\t\treturn false\r\n\t}\r\n\tlen = B % 128\r\n\tstart = hasMask ? 6 : 2\r\n\r\n\tif (this.buffer.length < start + len) {\r\n\t\t// Not enough data in the buffer\r\n\t\treturn\r\n\t}\r\n\r\n\t// Get the actual payload length\r\n\tif (len === 126) {\r\n\t\tlen = this.buffer.readUInt16BE(2)\r\n\t\tstart += 2\r\n\t} else if (len === 127) {\r\n\t\t// Warning: JS can only store up to 2^53 in its number format\r\n\t\tlen = this.buffer.readUInt32BE(2) * Math.pow(2, 32) + this.buffer.readUInt32BE(6)\r\n\t\tstart += 8\r\n\t}\r\n\tif (this.buffer.length < start + len) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// Extract the payload\r\n\tpayload = this.buffer.slice(start, start + len)\r\n\tif (hasMask) {\r\n\t\t// Decode with the given mask\r\n\t\tmask = this.buffer.slice(start - 4, start)\r\n\t\tfor (i = 0; i < payload.length; i++) {\r\n\t\t\tpayload[i] ^= mask[i % 4]\r\n\t\t}\r\n\t}\r\n\tthis.buffer = this.buffer.slice(start + len)\r\n\r\n\t// Proceeds to frame processing\r\n\treturn this.processFrame(fin, opcode, payload)\r\n}\r\n\r\n/**\r\n * Process a given frame received\r\n * @param {boolean} fin\r\n * @param {number} opcode\r\n * @param {Buffer} payload\r\n * @returns {boolean} false if any error occurs, true otherwise\r\n * @fires text\r\n * @fires binary\r\n * @private\r\n */\r\nConnection.prototype.processFrame = function (fin, opcode, payload) {\r\n\tif (opcode === 8) {\r\n\t\t// Close frame\r\n\t\tif (this.readyState === this.CLOSING) {\r\n\t\t\tthis.socket.end()\r\n\t\t} else if (this.readyState === this.OPEN) {\r\n\t\t\tthis.processCloseFrame(payload)\r\n\t\t}\r\n\t\treturn true\r\n\t} else if (opcode === 9) {\r\n\t\t// Ping frame\r\n\t\tif (this.readyState === this.OPEN) {\r\n\t\t\tthis.socket.write(frame.createPongFrame(payload.toString(), !this.server))\r\n\t\t}\r\n\t\treturn true\r\n\t} else if (opcode === 10) {\r\n\t\t// Pong frame\r\n\t\tthis.emit('pong', payload.toString())\r\n\t\treturn true\r\n\t}\r\n\r\n\tif (this.readyState !== this.OPEN) {\r\n\t\t// Ignores if the connection isn't opened anymore\r\n\t\treturn true\r\n\t}\r\n\r\n\tif (opcode === 0 && this.frameBuffer === null) {\r\n\t\t// Unexpected continuation frame\r\n\t\treturn false\r\n\t} else if (opcode !== 0 && this.frameBuffer !== null) {\r\n\t\t// Last sequence didn't finished correctly\r\n\t\treturn false\r\n\t}\r\n\r\n\tif (!opcode) {\r\n\t\t// Get the current opcode for fragmented frames\r\n\t\topcode = typeof this.frameBuffer === 'string' ? 1 : 2\r\n\t}\r\n\r\n\tif (opcode === 1) {\r\n\t\t// Save text frame\r\n\t\tpayload = payload.toString()\r\n\t\tthis.frameBuffer = this.frameBuffer ? this.frameBuffer + payload : payload\r\n\r\n\t\tif (fin) {\r\n\t\t\t// Emits 'text' event\r\n\t\t\tthis.emit('text', this.frameBuffer)\r\n\t\t\tthis.frameBuffer = null\r\n\t\t}\r\n\t} else {\r\n\t\t// Sends the buffer for InStream object\r\n\t\tif (!this.frameBuffer) {\r\n\t\t\t// Emits the 'binary' event\r\n\t\t\tthis.frameBuffer = new InStream\r\n\t\t\tthis.emit('binary', this.frameBuffer)\r\n\t\t}\r\n\t\tthis.frameBuffer.addData(payload)\r\n\r\n\t\tif (fin) {\r\n\t\t\t// Emits 'end' event\r\n\t\t\tthis.frameBuffer.end()\r\n\t\t\tthis.frameBuffer = null\r\n\t\t}\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\n/**\r\n * Process a close frame, emitting the close event and sending back the frame\r\n * @param {Buffer} payload\r\n * @fires close\r\n * @private\r\n */\r\nConnection.prototype.processCloseFrame = function (payload) {\r\n\tvar code, reason\r\n\tif (payload.length >= 2) {\r\n\t\tcode = payload.readUInt16BE(0)\r\n\t\treason = payload.slice(2).toString()\r\n\t} else {\r\n\t\tcode = 1005\r\n\t\treason = ''\r\n\t}\r\n\tthis.socket.write(frame.createCloseFrame(code, reason, !this.server))\r\n\tthis.readyState = this.CLOSED\r\n\tthis.emit('close', code, reason)\r\n}\r\n\r\n/**\r\n * Build the header string\r\n * @param {string} requestLine\r\n * @param {Object<string>} headers\r\n * @returns {string}\r\n * @private\r\n */\r\nConnection.prototype.buildRequest = function (requestLine, headers) {\r\n\tvar headerString = requestLine + '\\r\\n',\r\n\t\theaderName\r\n\r\n\tfor (headerName in headers) {\r\n\t\theaderString += headerName + ': ' + headers[headerName] + '\\r\\n'\r\n\t}\r\n\r\n\treturn headerString + '\\r\\n'\r\n}","/home/travis/build/npmtest/node-npmtest-nodejs-websocket/node_modules/nodejs-websocket/InStream.js":"/**\r\n * @file Simple wrapper for stream.Readable, used for receiving binary data\r\n */\r\n'use strict'\r\n\r\nvar util = require('util'),\r\n\tstream = require('stream')\r\n\r\n/**\r\n * Represents the readable stream for binary frames\r\n * @class\r\n * @event readable\r\n * @event end\r\n */\r\nfunction InStream() {\r\n\tstream.Readable.call(this)\r\n}\r\n\r\nmodule.exports = InStream\r\n\r\nutil.inherits(InStream, stream.Readable)\r\n\r\n/**\r\n * No logic here, the pushs are made outside _read\r\n * @private\r\n */\r\nInStream.prototype._read = function () {}\r\n\r\n/**\r\n * Add more data to the stream and fires \"readable\" event\r\n * @param {Buffer} data\r\n * @private\r\n */\r\nInStream.prototype.addData = function (data) {\r\n\tthis.push(data)\r\n}\r\n\r\n/**\r\n * Indicates there is no more data to add to the stream\r\n * @private\r\n */\r\nInStream.prototype.end = function () {\r\n\tthis.push(null)\r\n}","/home/travis/build/npmtest/node-npmtest-nodejs-websocket/node_modules/nodejs-websocket/OutStream.js":"/**\r\n * @file Simple wrapper for stream.Writable, used for sending binary data\r\n */\r\n'use strict'\r\n\r\nvar util = require('util'),\r\n\tstream = require('stream'),\r\n\tframe = require('./frame')\r\n\r\n/**\r\n * @class Represents the writable stream for binary frames\r\n * @param {Connection} connection\r\n * @param {number} minSize\r\n */\r\nfunction OutStream(connection, minSize) {\r\n\tvar that = this\r\n\tthis.connection = connection\r\n\tthis.minSize = minSize\r\n\tthis.buffer = new Buffer(0)\r\n\tthis.hasSent = false // Indicates if any frame has been sent yet\r\n\tstream.Writable.call(this)\r\n\tthis.on('finish', function () {\r\n\t\tif (that.connection.readyState === that.connection.OPEN) {\r\n\t\t\t// Ignore if not connected anymore\r\n\t\t\tthat.connection.socket.write(frame.createBinaryFrame(that.buffer, !that.connection.server, !that.hasSent, true))\r\n\t\t}\r\n\t\tthat.connection.outStream = null\r\n\t})\r\n}\r\n\r\nmodule.exports = OutStream\r\n\r\n\r\nutil.inherits(OutStream, stream.Writable)\r\n\r\n/**\r\n * @param {Buffer} chunk\r\n * @param {string} encoding\r\n * @param {Function} callback\r\n * @private\r\n */\r\nOutStream.prototype._write = function (chunk, encoding, callback) {\r\n\tvar frameBuffer\r\n\tthis.buffer = Buffer.concat([this.buffer, chunk], this.buffer.length + chunk.length)\r\n\tif (this.buffer.length >= this.minSize) {\r\n\t\tif (this.connection.readyState === this.connection.OPEN) {\r\n\t\t\t// Ignore if not connected anymore\r\n\t\t\tframeBuffer = frame.createBinaryFrame(this.buffer, !this.connection.server, !this.hasSent, false)\r\n\t\t\tthis.connection.socket.write(frameBuffer, encoding, callback)\r\n\t\t}\r\n\t\tthis.buffer = new Buffer(0)\r\n\t\tthis.hasSent = true\r\n\t\tif (this.connection.readyState !== this.connection.OPEN) {\r\n\t\t\tcallback()\r\n\t\t}\r\n\t} else {\r\n\t\tcallback()\r\n\t}\r\n}","/home/travis/build/npmtest/node-npmtest-nodejs-websocket/node_modules/nodejs-websocket/frame.js":"/**\r\n * @file Utility functions for creating frames\r\n */\r\n'use strict'\r\n\r\n/**\r\n * Creates a text frame\r\n * @param {string} data\r\n * @param {boolean} [masked=false] if the frame should be masked\r\n * @returns {Buffer}\r\n * @private\r\n */\r\nexports.createTextFrame = function (data, masked) {\r\n\tvar payload, meta\r\n\r\n\tpayload = new Buffer(data)\r\n\tmeta = generateMetaData(true, 1, masked === undefined ? false : masked, payload)\r\n\r\n\treturn Buffer.concat([meta, payload], meta.length + payload.length)\r\n}\r\n\r\n/**\r\n * Create a binary frame\r\n * @param {Buffer} data\r\n * @param {boolean} [masked=false] if the frame should be masked\r\n * @param {boolean} [first=true] if this is the first frame in a sequence\r\n * @param {boolean} [fin=true] if this is the final frame in a sequence\r\n * @returns {Buffer}\r\n * @private\r\n */\r\nexports.createBinaryFrame = function (data, masked, first, fin) {\r\n\tvar payload, meta\r\n\r\n\tfirst = first === undefined ? true : first\r\n\tmasked = masked === undefined ? false : masked\r\n\tif (masked) {\r\n\t\tpayload = new Buffer(data.length)\r\n\t\tdata.copy(payload)\r\n\t} else {\r\n\t\tpayload = data\r\n\t}\r\n\tmeta = generateMetaData(fin === undefined ? true : fin, first ? 2 : 0, masked, payload)\r\n\r\n\treturn Buffer.concat([meta, payload], meta.length + payload.length)\r\n}\r\n\r\n/**\r\n * Create a close frame\r\n * @param {number} code\r\n * @param {string} [reason='']\r\n * @param {boolean} [masked=false] if the frame should be masked\r\n * @returns {Buffer}\r\n * @private\r\n */\r\nexports.createCloseFrame = function (code, reason, masked) {\r\n\tvar payload, meta\r\n\r\n\tif (code !== undefined && code !== 1005) {\r\n\t\tpayload = new Buffer(reason === undefined ? '--' : '--' + reason)\r\n\t\tpayload.writeUInt16BE(code, 0)\r\n\t} else {\r\n\t\tpayload = new Buffer(0)\r\n\t}\r\n\tmeta = generateMetaData(true, 8, masked === undefined ? false : masked, payload)\r\n\r\n\treturn Buffer.concat([meta, payload], meta.length + payload.length)\r\n}\r\n\r\n/**\r\n * Create a ping frame\r\n * @param {string} data\r\n * @param {boolean} [masked=false] if the frame should be masked\r\n * @returns {Buffer}\r\n * @private\r\n */\r\nexports.createPingFrame = function (data, masked) {\r\n\tvar payload, meta\r\n\r\n\tpayload = new Buffer(data)\r\n\tmeta = generateMetaData(true, 9, masked === undefined ? false : masked, payload)\r\n\r\n\treturn Buffer.concat([meta, payload], meta.length + payload.length)\r\n}\r\n\r\n/**\r\n * Create a pong frame\r\n * @param {string} data\r\n * @param {boolean} [masked=false] if the frame should be masked\r\n * @returns {Buffer}\r\n * @private\r\n */\r\nexports.createPongFrame = function (data, masked) {\r\n\tvar payload, meta\r\n\r\n\tpayload = new Buffer(data)\r\n\tmeta = generateMetaData(true, 10, masked === undefined ? false : masked, payload)\r\n\r\n\treturn Buffer.concat([meta, payload], meta.length + payload.length)\r\n}\r\n\r\n/**\r\n * Creates the meta-data portion of the frame\r\n * If the frame is masked, the payload is altered accordingly\r\n * @param {boolean} fin\r\n * @param {number} opcode\r\n * @param {boolean} masked\r\n * @param {Buffer} payload\r\n * @returns {Buffer}\r\n * @private\r\n */\r\nfunction generateMetaData(fin, opcode, masked, payload) {\r\n\tvar len, meta, start, mask, i\r\n\r\n\tlen = payload.length\r\n\r\n\t// Creates the buffer for meta-data\r\n\tmeta = new Buffer(2 + (len < 126 ? 0 : (len < 65536 ? 2 : 8)) + (masked ? 4 : 0))\r\n\r\n\t// Sets fin and opcode\r\n\tmeta[0] = (fin ? 128 : 0) + opcode\r\n\r\n\t// Sets the mask and length\r\n\tmeta[1] = masked ? 128 : 0\r\n\tstart = 2\r\n\tif (len < 126) {\r\n\t\tmeta[1] += len\r\n\t} else if (len < 65536) {\r\n\t\tmeta[1] += 126\r\n\t\tmeta.writeUInt16BE(len, 2)\r\n\t\tstart += 2\r\n\t} else {\r\n\t\t// Warning: JS doesn't support integers greater than 2^53\r\n\t\tmeta[1] += 127\r\n\t\tmeta.writeUInt32BE(Math.floor(len / Math.pow(2, 32)), 2)\r\n\t\tmeta.writeUInt32BE(len % Math.pow(2, 32), 6)\r\n\t\tstart += 8\r\n\t}\r\n\r\n\t// Set the mask-key\r\n\tif (masked) {\r\n\t\tmask = new Buffer(4)\r\n\t\tfor (i = 0; i < 4; i++) {\r\n\t\t\tmeta[start + i] = mask[i] = Math.floor(Math.random() * 256)\r\n\t\t}\r\n\t\tfor (i = 0; i < payload.length; i++) {\r\n\t\t\tpayload[i] ^= mask[i % 4]\r\n\t\t}\r\n\t\tstart += 4\r\n\t}\r\n\r\n\treturn meta\r\n}"}